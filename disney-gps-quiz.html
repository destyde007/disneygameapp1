<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disney GPS –í–∏–∫—Ç–æ—Ä–∏–Ω–∞</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
            font-size: 24px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .setup-screen, .map-selector-screen, .map-screen, .question-screen, .results-screen {
            display: none;
        }

        .setup-screen.active, .map-selector-screen.active, .map-screen.active, .question-screen.active, .results-screen.active {
            display: block;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
        }

        input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .location-status {
            background: #f0f4ff;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            color: #667eea;
            font-size: 14px;
        }

        #map {
            height: 400px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .map-info {
            background: #f0f4ff;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .map-legend {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            font-size: 13px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-dot.locked {
            background: #f44336;
        }

        .legend-dot.unlocked {
            background: #4caf50;
        }

        .legend-dot.answered {
            background: #2196f3;
        }

        .legend-dot.current {
            background: #ff9800;
        }

        .question-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .question-text {
            font-size: 18px;
            color: #333;
            margin-bottom: 20px;
            font-weight: 600;
            line-height: 1.5;
        }

        .proximity-warning {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
        }

        .proximity-ok {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .option {
            padding: 15px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
        }

        .option:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .option.selected {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .option.correct {
            border-color: #4caf50;
            background: #4caf50;
            color: white;
        }

        .option.incorrect {
            border-color: #f44336;
            background: #f44336;
            color: white;
        }

        .option.disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .results-summary {
            text-align: center;
            margin-bottom: 30px;
        }

        .score {
            font-size: 48px;
            color: #667eea;
            font-weight: bold;
            margin: 20px 0;
        }

        .score-text {
            font-size: 18px;
            color: #666;
            margin-bottom: 10px;
        }

        .feedback {
            font-size: 16px;
            color: #333;
            margin-top: 15px;
        }

        .results-list {
            margin-top: 30px;
        }

        .result-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .result-item.correct {
            border-left: 4px solid #4caf50;
        }

        .result-item.incorrect {
            border-left: 4px solid #f44336;
        }

        .result-question {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .result-answer {
            font-size: 14px;
            color: #666;
        }

        small {
            color: #666;
            margin-top: 5px;
            display: block;
            font-size: 13px;
        }

        .tool-btn {
            padding: 10px 15px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .tool-btn:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .tool-btn.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .question-image {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 10px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üè∞ Disney GPS –í–∏–∫—Ç–æ—Ä–∏–Ω–∞</h1>
        <p class="subtitle">–ü—Ä–∏–∫–ª—é—á–µ–Ω–∏–µ –∂–¥—ë—Ç –≤–∞—Å!</p>

        <!-- Setup Screen -->
        <div class="setup-screen active">
            <div class="location-status" id="locationStatus">
                üìç –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≤–∞—à–µ–≥–æ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è...
            </div>
            
            <div class="input-group">
                <label for="questionCount">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ–ø—Ä–æ—Å–æ–≤ (1-15)</label>
                <input type="number" id="questionCount" min="1" max="15" value="5" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ–ø—Ä–æ—Å–æ–≤">
            </div>

            <div class="input-group">
                <label for="mapStyle">–°—Ç–∏–ª—å –∫–∞—Ä—Ç—ã</label>
                <select id="mapStyle" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 10px; font-size: 16px; background: white;">
                    <option value="street">–û–±—ã—á–Ω–∞—è –∫–∞—Ä—Ç–∞</option>
                    <option value="satellite">–°–ø—É—Ç–Ω–∏–∫</option>
                </select>
            </div>

            <button class="btn" id="startBtn" onclick="showMapSelector()" disabled>–í—ã–±—Ä–∞—Ç—å –æ–±–ª–∞—Å—Ç—å –Ω–∞ –∫–∞—Ä—Ç–µ</button>
        </div>

        <!-- Map Selector Screen -->
        <div class="map-selector-screen">
            <div class="map-info">
                <div style="font-weight: 600; margin-bottom: 10px;">üéØ –ù–∞—Ä–∏—Å—É–π—Ç–µ –æ–±–ª–∞—Å—Ç—å –¥–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤</div>
                <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
                    –í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –∏ –Ω–∞—Ä–∏—Å—É–π—Ç–µ –æ–±–ª–∞—Å—Ç—å –Ω–∞ –∫–∞—Ä—Ç–µ
                </div>
            </div>

            <div class="drawing-tools" style="background: #f0f4ff; padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                <div style="font-weight: 600; margin-bottom: 10px;">–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —Ä–∏—Å–æ–≤–∞–Ω–∏—è:</div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="selectDrawingTool('circle')" id="tool-circle" class="tool-btn active">
                        ‚≠ï –ö—Ä—É–≥
                    </button>
                    <button onclick="selectDrawingTool('rectangle')" id="tool-rectangle" class="tool-btn">
                        ‚¨ú –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫
                    </button>
                    <button onclick="selectDrawingTool('polygon')" id="tool-polygon" class="tool-btn">
                        üî∂ –°–≤–æ–±–æ–¥–Ω–∞—è —Ñ–æ—Ä–º–∞
                    </button>
                    <button onclick="clearDrawing()" class="tool-btn" style="background: #f44336;">
                        üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å
                    </button>
                </div>
                <div id="drawingHint" style="margin-top: 10px; font-size: 13px; color: #666;">
                    –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–∞—Ä—Ç—É, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Ä–∏—Å–æ–≤–∞—Ç—å –∫—Ä—É–≥
                </div>
            </div>
            
            <div id="selectorMap" style="height: 400px; border-radius: 15px; margin-bottom: 20px;"></div>
            
            <button class="btn" onclick="confirmAreaSelection()">–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –æ–±–ª–∞—Å—Ç—å</button>
            <button class="btn" onclick="backToSetup()" style="background: #6c757d; margin-top: 10px;">–ù–∞–∑–∞–¥</button>
        </div>

        <!-- Map Screen -->
        <div class="map-screen">
            <div class="map-info">
                <div style="font-weight: 600; margin-bottom: 10px;">üó∫Ô∏è –ö–∞—Ä—Ç–∞ –≤–æ–ø—Ä–æ—Å–æ–≤</div>
                <div style="font-size: 14px; color: #666;">–ü–æ–¥–æ–π–¥–∏—Ç–µ –∫ –≤–æ–ø—Ä–æ—Å—É –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ 15–º, —á—Ç–æ–±—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –µ–≥–æ</div>
                <div class="map-legend">
                    <div class="legend-item">
                        <div class="legend-dot locked"></div>
                        <span>–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot unlocked"></div>
                        <span>–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot answered"></div>
                        <span>–û—Ç–≤–µ—á–µ–Ω</span>
                    </div>
                </div>
            </div>
            
            <div id="map"></div>
            
            <button class="btn" onclick="showResults()">–ó–∞–≤–µ—Ä—à–∏—Ç—å –≤–∏–∫—Ç–æ—Ä–∏–Ω—É</button>
        </div>

        <!-- Question Screen -->
        <div class="question-screen">
            <div id="proximityStatus"></div>
            
            <div class="question-card">
                <div class="question-text" id="questionText"></div>
                <div class="options" id="optionsContainer"></div>
            </div>

            <button class="btn" onclick="backToMap()">–í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –∫–∞—Ä—Ç—É</button>
        </div>

        <!-- Results Screen -->
        <div class="results-screen">
            <div class="results-summary">
                <h2>üéâ –í–∏–∫—Ç–æ—Ä–∏–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</h2>
                <div class="score" id="finalScore">0/5</div>
                <div class="score-text">–ü—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤</div>
                <div class="feedback" id="feedback"></div>
            </div>

            <div class="results-list" id="resultsList"></div>

            <button class="btn" onclick="resetGame()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
        </div>
    </div>

    <script>
        // Game state
        let userLocation = null;
        let map = null;
        let selectorMap = null;
        let selectionCircle = null;
        let centerMarker = null;
        let selectedCenter = null;
        let userMarker = null;
        let questionMarkers = [];
        let radius = 500;
        let questionCount = 5;
        let questions = [];
        let score = 0;
        let watchId = null;
        let currentHeading = 0;
        let mapStyle = 'street';
        let tileLayer = null;
        let currentDrawingTool = 'circle';
        let drawnShape = null;
        let isDrawing = false;
        let drawingPoints = [];
        const UNLOCK_DISTANCE = 15; // meters

        // Disney cartoon quiz questions pool in Russian
        const questionPool = [
            {
                question: "–ö–∞–∫ –∑–æ–≤—É—Ç –æ—Ç—Ü–∞ –°–∏–º–±—ã –≤ '–ö–æ—Ä–æ–ª–µ –õ—å–≤–µ'?",
                options: ["–®—Ä–∞–º", "–ú—É—Ñ–∞—Å–∞", "–†–∞—Ñ–∏–∫–∏"],
                correct: 1,
                image: "https://images.unsplash.com/photo-1556103255-4443dbae8e5a?w=800&auto=format&fit=crop"
            },
            {
                question: "–£ –∫–∞–∫–æ–π –¥–∏—Å–Ω–µ–µ–≤—Å–∫–æ–π –ø—Ä–∏–Ω—Ü–µ—Å—Å—ã –µ—Å—Ç—å —Ç–∏–≥—Ä –ø–æ –∏–º–µ–Ω–∏ –†–∞–¥–∂–∞?",
                options: ["–ñ–∞—Å–º–∏–Ω", "–ë–µ–ª–ª—å", "–ê—Ä–∏—ç–ª—å"],
                correct: 0,
                image: "https://images.unsplash.com/photo-1568605117036-5fe5e7bab0b7?w=800&auto=format&fit=crop"
            },
            {
                question: "–ö–∞–∫–æ–µ –∂–∏–≤–æ—Ç–Ω–æ–µ –ë–∞–ª—É –∏–∑ '–ö–Ω–∏–≥–∏ –¥–∂—É–Ω–≥–ª–µ–π'?",
                options: ["–ü–∞–Ω—Ç–µ—Ä–∞", "–ú–µ–¥–≤–µ–¥—å", "–°–ª–æ–Ω"],
                correct: 1,
                image: "https://images.unsplash.com/photo-1589656966895-2f33e7653819?w=800&auto=format&fit=crop"
            },
            {
                question: "–ö–∞–∫ –∑–æ–≤—É—Ç —Å–µ—Å—Ç—Ä—É –ê–Ω–Ω—ã –≤ '–•–æ–ª–æ–¥–Ω–æ–º —Å–µ—Ä–¥—Ü–µ'?",
                options: ["–≠–ª—å–∑–∞", "–†–∞–ø—É–Ω—Ü–µ–ª—å", "–ú–æ–∞–Ω–∞"],
                correct: 0,
                image: "https://images.unsplash.com/photo-1483381719261-1d7f82f8c364?w=800&auto=format&fit=crop"
            },
            {
                question: "–ß—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç '–ê–∫—É–Ω–∞ –ú–∞—Ç–∞—Ç–∞'?",
                options: ["–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ", "–ù–µ—Ç –ø—Ä–æ–±–ª–µ–º", "–°–ø–∞—Å–∏–±–æ"],
                correct: 1,
                image: "https://images.unsplash.com/photo-1516426122078-c23e76319801?w=800&auto=format&fit=crop"
            },
            {
                question: "–í –∫–∞–∫–æ–º –¥–∏—Å–Ω–µ–µ–≤—Å–∫–æ–º —Ñ–∏–ª—å–º–µ –∑–≤—É—á–∏—Ç –ø–µ—Å–Ω—è '–¶–µ–ª—ã–π –Ω–æ–≤—ã–π –º–∏—Ä'?",
                options: ["–ê–ª–∞–¥–¥–∏–Ω", "–ö—Ä–∞—Å–∞–≤–∏—Ü–∞ –∏ –ß—É–¥–æ–≤–∏—â–µ", "–ú—É–ª–∞–Ω"],
                correct: 0,
                image: "https://images.unsplash.com/photo-1559827260-dc66d52bef19?w=800&auto=format&fit=crop"
            },
            {
                question: "–ö–∞–∫ –∑–æ–≤—É—Ç –¥—Ä—É–≥–∞-—Ä—ã–±–∫—É –ê—Ä–∏—ç–ª—å –≤ '–†—É—Å–∞–ª–æ—á–∫–µ'?",
                options: ["–°–µ–±–∞—Å—Ç—å—è–Ω", "–§–ª–∞—É–Ω–¥–µ—Ä", "–°–∫–∞—Ç—Ç–ª"],
                correct: 1,
                image: "https://images.unsplash.com/photo-1559827260-dc66d52bef19?w=800&auto=format&fit=crop"
            },
            {
                question: "–ö–∞–∫ –∑–æ–≤—É—Ç —Å–æ—Å–µ–¥–∞ –≠–Ω–¥–∏ –≤ '–ò—Å—Ç–æ—Ä–∏–∏ –∏–≥—Ä—É—à–µ–∫'?",
                options: ["–°–∏–¥", "–†–µ–∫—Å", "–í—É–¥–∏"],
                correct: 0,
                image: "https://images.unsplash.com/photo-1587731556938-38755b4803a6?w=800&auto=format&fit=crop"
            },
            {
                question: "–ö–∞–∫–æ–µ –∂–∏–≤–æ—Ç–Ω–æ–µ –¢–∏–º–æ–Ω –∏–∑ '–ö–æ—Ä–æ–ª—è –õ—å–≤–∞'?",
                options: ["–ë–æ—Ä–æ–¥–∞–≤–æ—á–Ω–∏–∫", "–°—É—Ä–∏–∫–∞—Ç", "–ì–∏–µ–Ω–∞"],
                correct: 1,
                image: "https://images.unsplash.com/photo-1535930891776-0c2dfb7fda1a?w=800&auto=format&fit=crop"
            },
            {
                question: "–ö–∞–∫–æ–π –ø–µ—Ä—Å–æ–Ω–∞–∂ Disney –≥–æ–≤–æ—Ä–∏—Ç '–ü—Ä–æ—Å—Ç–æ –ø–ª—ã–≤–∏ –¥–∞–ª—å—à–µ'?",
                options: ["–ù–µ–º–æ", "–î–æ—Ä–∏", "–ú–∞—Ä–ª–∏–Ω"],
                correct: 1,
                image: "https://images.unsplash.com/photo-1544551763-46a013bb70d5?w=800&auto=format&fit=crop"
            },
            {
                question: "–ö–∞–∫ –∑–æ–≤—É—Ç –¥—Ä–∞–∫–æ–Ω–∞-—Å–ø—É—Ç–Ω–∏–∫–∞ –ú—É–ª–∞–Ω?",
                options: ["–ú—É—à—É", "–ö—Ä–∏-–ö–∏", "–•–∞–Ω"],
                correct: 0,
                image: "https://images.unsplash.com/photo-1451772741724-d20990422508?w=800&auto=format&fit=crop"
            },
            {
                question: "–ö–∞–∫ –∑–æ–≤—É—Ç –æ—Ç—Ü–∞ –ë–µ–ª–ª—å –≤ '–ö—Ä–∞—Å–∞–≤–∏—Ü–µ –∏ –ß—É–¥–æ–≤–∏—â–µ'?",
                options: ["–ì–∞—Å—Ç–æ–Ω", "–ú–æ—Ä–∏—Å", "–õ—é–º—å–µ—Ä"],
                correct: 1,
                image: "https://images.unsplash.com/photo-1518709268805-4e9042af9f23?w=800&auto=format&fit=crop"
            },
            {
                question: "–í–æ —á—Ç–æ —Ñ–µ—è-–∫—Ä—ë—Å—Ç–Ω–∞—è –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –∫–∞—Ä–µ—Ç—É –ó–æ–ª—É—à–∫–∏?",
                options: ["–Ø–±–ª–æ–∫–æ", "–¢—ã–∫–≤–∞", "–ê—Ä–±—É–∑"],
                correct: 1,
                image: "https://images.unsplash.com/photo-1570043849279-7d0ca4675682?w=800&auto=format&fit=crop"
            },
            {
                question: "–ö–∞–∫–æ–π –≥–Ω–æ–º –≤ '–ë–µ–ª–æ—Å–Ω–µ–∂–∫–µ' –Ω–æ—Å–∏—Ç –æ—á–∫–∏?",
                options: ["–î–æ–∫", "–í–æ—Ä—á—É–Ω", "–°–∫—Ä–æ–º–Ω–∏–∫"],
                correct: 0,
                image: "https://images.unsplash.com/photo-1509310982748-a9f5a0a00c7f?w=800&auto=format&fit=crop"
            },
            {
                question: "–ö–∞–∫ –∑–æ–≤—É—Ç —Ö–∞–º–µ–ª–µ–æ–Ω–∞ –†–∞–ø—É–Ω—Ü–µ–ª—å –≤ '–†–∞–ø—É–Ω—Ü–µ–ª—å'?",
                options: ["–§–ª–∏–Ω–Ω", "–ü–∞—Å–∫–∞–ª—å", "–ú–∞–∫—Å–∏–º—É—Å"],
                correct: 1,
                image: "https://images.unsplash.com/photo-1576859898415-f53858c0de0a?w=800&auto=format&fit=crop"
            }
        ];

        // Initialize the game
        window.onload = function() {
            getUserLocation();
        };

        // Get user's current location
        function getUserLocation() {
            if (!navigator.geolocation) {
                document.getElementById('locationStatus').innerHTML = '‚ùå –ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤–∞—à–∏–º –±—Ä–∞—É–∑–µ—Ä–æ–º';
                return;
            }

            navigator.geolocation.getCurrentPosition(
                position => {
                    userLocation = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude
                    };
                    document.getElementById('locationStatus').innerHTML = 
                        `‚úÖ –ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ –Ω–∞–π–¥–µ–Ω–æ: ${userLocation.lat.toFixed(6)}, ${userLocation.lng.toFixed(6)}`;
                    document.getElementById('startBtn').disabled = false;
                },
                error => {
                    document.getElementById('locationStatus').innerHTML = 
                        `‚ùå –û—à–∏–±–∫–∞: ${error.message}. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ä–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—é.`;
                }
            );
        }

        // Show map selector screen
        function showMapSelector() {
            questionCount = parseInt(document.getElementById('questionCount').value);
            mapStyle = document.getElementById('mapStyle').value;
            
            if (!userLocation) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ä–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—é!');
                return;
            }

            if (questionCount < 1 || questionCount > 15) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ–ø—Ä–æ—Å–æ–≤ –æ—Ç 1 –¥–æ 15');
                return;
            }

            showScreen('map-selector-screen');
            initSelectorMap();
        }

        // Initialize the selector map
        function initSelectorMap() {
            if (selectorMap) {
                selectorMap.remove();
            }

            selectorMap = L.map('selectorMap', {
                doubleClickZoom: false  // Disable double-click zoom for polygon drawing
            }).setView([userLocation.lat, userLocation.lng], 15);
            
            // Add tile layer based on selected style
            const tileUrls = {
                street: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                satellite: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
            };
            
            const attributions = {
                street: '¬© OpenStreetMap contributors',
                satellite: '¬© Esri, Maxar, Earthstar Geographics'
            };
            
            L.tileLayer(tileUrls[mapStyle], {
                attribution: attributions[mapStyle]
            }).addTo(selectorMap);

            // Add user location marker
            L.marker([userLocation.lat, userLocation.lng], {
                icon: L.divIcon({
                    className: 'user-marker',
                    html: '<div style="background: #2196f3; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                })
            }).addTo(selectorMap);

            // Setup drawing interaction
            setupDrawing();
        }

        // Select drawing tool
        function selectDrawingTool(tool) {
            currentDrawingTool = tool;
            
            // Update button states
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('tool-' + tool).classList.add('active');
            
            // Update hint
            const hints = {
                circle: '–ù–∞–∂–º–∏—Ç–µ –∏ —É–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ, –∑–∞—Ç–µ–º –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫—Ä—É–≥–∞',
                rectangle: '–ù–∞–∂–º–∏—Ç–µ –∏ —É–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ, –∑–∞—Ç–µ–º –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞',
                polygon: '–ù–∞–∂–∏–º–∞–π—Ç–µ –Ω–∞ –∫–∞—Ä—Ç—É –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ—á–µ–∫. –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è'
            };
            document.getElementById('drawingHint').textContent = hints[tool];
            
            // Clear previous drawing state
            isDrawing = false;
            drawingPoints = [];
        }

        // Clear drawn shape
        function clearDrawing() {
            if (drawnShape) {
                selectorMap.removeLayer(drawnShape);
                drawnShape = null;
                selectedCenter = null;
            }
            isDrawing = false;
            drawingPoints = [];
        }

        // Setup drawing interaction
        function setupDrawing() {
            let startPoint = null;
            let tempShape = null;
            let isMouseDown = false;

            selectorMap.on('mousedown', function(e) {
                if (currentDrawingTool === 'polygon') {
                    return; // Polygon uses click events
                }
                
                isMouseDown = true;
                startPoint = e.latlng;
                isDrawing = true;
                
                if (drawnShape) {
                    selectorMap.removeLayer(drawnShape);
                    drawnShape = null;
                }
            });

            selectorMap.on('click', function(e) {
                if (currentDrawingTool === 'polygon') {
                    // Add point to polygon
                    drawingPoints.push(e.latlng);
                    
                    if (drawingPoints.length === 1) {
                        isDrawing = true;
                        if (drawnShape) {
                            selectorMap.removeLayer(drawnShape);
                            drawnShape = null;
                        }
                    }
                    
                    // Draw temporary polygon
                    if (tempShape) {
                        selectorMap.removeLayer(tempShape);
                    }
                    
                    if (drawingPoints.length >= 2) {
                        tempShape = L.polygon(drawingPoints, {
                            color: '#667eea',
                            fillColor: '#667eea',
                            fillOpacity: 0.2,
                            weight: 3
                        }).addTo(selectorMap);
                    } else if (drawingPoints.length === 1) {
                        // Show a marker for the first point
                        tempShape = L.circleMarker(drawingPoints[0], {
                            radius: 5,
                            color: '#667eea',
                            fillColor: '#667eea',
                            fillOpacity: 0.5
                        }).addTo(selectorMap);
                    }
                }
            });

            selectorMap.on('dblclick', function(e) {
                L.DomEvent.stop(e);
                
                if (currentDrawingTool === 'polygon' && drawingPoints.length >= 3) {
                    // Finish polygon
                    if (tempShape) {
                        selectorMap.removeLayer(tempShape);
                    }
                    
                    drawnShape = L.polygon(drawingPoints, {
                        color: '#667eea',
                        fillColor: '#667eea',
                        fillOpacity: 0.2,
                        weight: 3
                    }).addTo(selectorMap);
                    
                    // Calculate center
                    const bounds = drawnShape.getBounds();
                    selectedCenter = bounds.getCenter();
                    
                    isDrawing = false;
                    drawingPoints = [];
                    
                    document.getElementById('drawingHint').textContent = '‚úì –§–æ—Ä–º–∞ —Å–æ–∑–¥–∞–Ω–∞! –ú–æ–∂–µ—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∏–ª–∏ –Ω–∞—Ä–∏—Å–æ–≤–∞—Ç—å –∑–∞–Ω–æ–≤–æ';
                }
            });

            selectorMap.on('mousemove', function(e) {
                if (!isMouseDown || !startPoint) return;

                if (currentDrawingTool === 'circle') {
                    const radius = startPoint.distanceTo(e.latlng);
                    
                    if (tempShape) {
                        selectorMap.removeLayer(tempShape);
                    }
                    
                    tempShape = L.circle(startPoint, {
                        radius: radius,
                        color: '#667eea',
                        fillColor: '#667eea',
                        fillOpacity: 0.2,
                        weight: 3
                    }).addTo(selectorMap);
                    
                } else if (currentDrawingTool === 'rectangle') {
                    if (tempShape) {
                        selectorMap.removeLayer(tempShape);
                    }
                    
                    const bounds = L.latLngBounds(startPoint, e.latlng);
                    tempShape = L.rectangle(bounds, {
                        color: '#667eea',
                        fillColor: '#667eea',
                        fillOpacity: 0.2,
                        weight: 3
                    }).addTo(selectorMap);
                }
            });

            selectorMap.on('mouseup', function(e) {
                if (!isMouseDown || !startPoint) return;
                isMouseDown = false;

                if (currentDrawingTool === 'circle') {
                    const radius = startPoint.distanceTo(e.latlng);
                    
                    if (radius < 10) {
                        // Too small, ignore
                        if (tempShape) {
                            selectorMap.removeLayer(tempShape);
                            tempShape = null;
                        }
                        isDrawing = false;
                        return;
                    }
                    
                    if (tempShape) {
                        selectorMap.removeLayer(tempShape);
                    }
                    
                    drawnShape = L.circle(startPoint, {
                        radius: radius,
                        color: '#667eea',
                        fillColor: '#667eea',
                        fillOpacity: 0.2,
                        weight: 3
                    }).addTo(selectorMap);
                    
                    selectedCenter = startPoint;
                    isDrawing = false;
                    startPoint = null;
                    
                    document.getElementById('drawingHint').textContent = '‚úì –ö—Ä—É–≥ —Å–æ–∑–¥–∞–Ω! –ú–æ–∂–µ—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∏–ª–∏ –Ω–∞—Ä–∏—Å–æ–≤–∞—Ç—å –∑–∞–Ω–æ–≤–æ';
                    
                } else if (currentDrawingTool === 'rectangle') {
                    if (tempShape) {
                        selectorMap.removeLayer(tempShape);
                    }
                    
                    const bounds = L.latLngBounds(startPoint, e.latlng);
                    
                    // Check if rectangle is too small
                    const size = startPoint.distanceTo(e.latlng);
                    if (size < 10) {
                        isDrawing = false;
                        return;
                    }
                    
                    drawnShape = L.rectangle(bounds, {
                        color: '#667eea',
                        fillColor: '#667eea',
                        fillOpacity: 0.2,
                        weight: 3
                    }).addTo(selectorMap);
                    
                    selectedCenter = bounds.getCenter();
                    isDrawing = false;
                    startPoint = null;
                    
                    document.getElementById('drawingHint').textContent = '‚úì –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ —Å–æ–∑–¥–∞–Ω! –ú–æ–∂–µ—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∏–ª–∏ –Ω–∞—Ä–∏—Å–æ–≤–∞—Ç—å –∑–∞–Ω–æ–≤–æ';
                }
            });
        }

        // Update circle radius from slider (removed - no longer needed)
        function updateCircleRadius(value) {
            // This function is no longer used but kept for compatibility
        }

        // Confirm area selection and start game
        function confirmAreaSelection() {
            if (!drawnShape) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—Ä–∏—Å—É–π—Ç–µ –æ–±–ª–∞—Å—Ç—å –Ω–∞ –∫–∞—Ä—Ç–µ');
                return;
            }

            if (!selectedCenter) {
                alert('–û—à–∏–±–∫–∞: —Ü–µ–Ω—Ç—Ä –æ–±–ª–∞—Å—Ç–∏ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω');
                return;
            }

            startGame();
        }

        // Back to setup screen
        function backToSetup() {
            if (selectorMap) {
                selectorMap.remove();
                selectorMap = null;
            }
            showScreen('setup-screen');
        }

        // Start tracking user location
        function startLocationTracking() {
            if (navigator.geolocation) {
                watchId = navigator.geolocation.watchPosition(
                    position => {
                        userLocation = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude
                        };
                        updateUserMarker();
                        updateQuestionStatuses();
                    },
                    error => console.error('Location tracking error:', error),
                    { enableHighAccuracy: true, maximumAge: 0 }
                );
            }
        }

        // Stop tracking user location
        function stopLocationTracking() {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
        }

        // Start the game
        function startGame() {
            if (!userLocation) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ä–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—é!');
                return;
            }

            if (!selectedCenter) {
                selectedCenter = {lat: userLocation.lat, lng: userLocation.lng};
            }

            // Select random questions
            questions = getRandomQuestions(questionCount);
            
            // Assign random locations to questions within the selected area
            questions.forEach((q, index) => {
                q.id = index;
                q.location = getRandomLocationInRadius(selectedCenter, radius);
                q.distance = calculateDistance(userLocation, q.location);
                q.unlocked = false;
                q.answered = false;
                q.userAnswer = null;
            });

            score = 0;

            // Clean up selector map
            if (selectorMap) {
                selectorMap.remove();
                selectorMap = null;
            }

            showScreen('map-screen');
            initMap();
            startLocationTracking();
            startCompassTracking();
        }

        // Initialize map
        function initMap() {
            if (map) {
                map.remove();
            }

            map = L.map('map').setView([userLocation.lat, userLocation.lng], 16);
            
            // Add tile layer based on selected style
            const tileUrls = {
                street: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                satellite: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
            };
            
            const attributions = {
                street: '¬© OpenStreetMap contributors',
                satellite: '¬© Esri, Maxar, Earthstar Geographics'
            };
            
            tileLayer = L.tileLayer(tileUrls[mapStyle], {
                attribution: attributions[mapStyle]
            }).addTo(map);

            // Add user marker with compass arrow
            userMarker = L.marker([userLocation.lat, userLocation.lng], {
                icon: L.divIcon({
                    className: 'user-marker',
                    html: `<div style="position: relative; width: 40px; height: 40px;">
                        <div style="background: rgba(33, 150, 243, 0.2); width: 40px; height: 40px; border-radius: 50%; border: 2px solid #2196f3; position: absolute; top: 0; left: 0;"></div>
                        <div style="background: #2196f3; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3); position: absolute; top: 12px; left: 12px;"></div>
                        <div id="compass-arrow" style="position: absolute; top: -5px; left: 16px; width: 0; height: 0; border-left: 4px solid transparent; border-right: 4px solid transparent; border-bottom: 20px solid #ff5722; transform-origin: 4px 15px; transform: rotate(${currentHeading}deg); filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));"></div>
                    </div>`,
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                })
            }).addTo(map);

            // Add question markers
            questions.forEach((q, index) => {
                const color = q.answered ? '#2196f3' : (q.unlocked ? '#4caf50' : '#f44336');
                const marker = L.marker([q.location.lat, q.location.lng], {
                    icon: L.divIcon({
                        className: 'question-marker',
                        html: `<div style="background: ${color}; width: 30px; height: 30px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${index + 1}</div>`,
                        iconSize: [30, 30]
                    })
                }).addTo(map);

                marker.on('click', () => openQuestion(index));
                questionMarkers.push(marker);
            });

            // Draw the selected area shape on the game map
            if (drawnShape) {
                const shapeOptions = {
                    color: '#667eea',
                    fillColor: '#667eea',
                    fillOpacity: 0.1,
                    weight: 2
                };

                if (currentDrawingTool === 'circle') {
                    L.circle([selectedCenter.lat, selectedCenter.lng], {
                        radius: drawnShape.getRadius(),
                        ...shapeOptions
                    }).addTo(map);
                } else if (currentDrawingTool === 'rectangle') {
                    L.rectangle(drawnShape.getBounds(), shapeOptions).addTo(map);
                } else if (currentDrawingTool === 'polygon') {
                    L.polygon(drawnShape.getLatLngs()[0], shapeOptions).addTo(map);
                }
            }

            // Mark the center of selection area
            L.marker([selectedCenter.lat, selectedCenter.lng], {
                icon: L.divIcon({
                    className: 'center-marker',
                    html: '<div style="background: #ff5722; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>',
                    iconSize: [12, 12],
                    iconAnchor: [6, 6]
                })
            }).addTo(map);
        }

        // Update user marker position
        function updateUserMarker() {
            if (userMarker && map) {
                userMarker.setLatLng([userLocation.lat, userLocation.lng]);
                userMarker.setIcon(L.divIcon({
                    className: 'user-marker',
                    html: `<div style="position: relative; width: 40px; height: 40px;">
                        <div style="background: rgba(33, 150, 243, 0.2); width: 40px; height: 40px; border-radius: 50%; border: 2px solid #2196f3; position: absolute; top: 0; left: 0;"></div>
                        <div style="background: #2196f3; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3); position: absolute; top: 12px; left: 12px;"></div>
                        <div id="compass-arrow" style="position: absolute; top: -5px; left: 16px; width: 0; height: 0; border-left: 4px solid transparent; border-right: 4px solid transparent; border-bottom: 20px solid #ff5722; transform-origin: 4px 15px; transform: rotate(${currentHeading}deg); filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));"></div>
                    </div>`,
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                }));
            }
        }

        // Update question unlock statuses
        function updateQuestionStatuses() {
            questions.forEach((q, index) => {
                if (!q.answered) {
                    q.distance = calculateDistance(userLocation, q.location);
                    const wasUnlocked = q.unlocked;
                    q.unlocked = q.distance <= UNLOCK_DISTANCE;
                    
                    if (q.unlocked !== wasUnlocked) {
                        updateMarkerColor(index);
                    }
                }
            });
        }

        // Start tracking device compass/orientation
        function startCompassTracking() {
            if ('ondeviceorientationabsolute' in window) {
                window.addEventListener('deviceorientationabsolute', handleOrientation, true);
            } else if ('ondeviceorientation' in window) {
                window.addEventListener('deviceorientation', handleOrientation, true);
            }
        }

        // Stop tracking device compass/orientation
        function stopCompassTracking() {
            window.removeEventListener('deviceorientationabsolute', handleOrientation, true);
            window.removeEventListener('deviceorientation', handleOrientation, true);
        }

        // Handle device orientation changes
        function handleOrientation(event) {
            let heading = event.webkitCompassHeading || event.alpha;
            
            if (heading !== null && heading !== undefined) {
                // For iOS: webkitCompassHeading gives true north
                // For Android: alpha needs to be inverted
                if (event.webkitCompassHeading) {
                    currentHeading = heading;
                } else {
                    currentHeading = 360 - heading;
                }
                
                updateUserMarker();
            }
        }

        // Update marker color
        function updateMarkerColor(index) {
            const q = questions[index];
            const color = q.answered ? '#2196f3' : (q.unlocked ? '#4caf50' : '#f44336');
            
            if (questionMarkers[index]) {
                questionMarkers[index].setIcon(L.divIcon({
                    className: 'question-marker',
                    html: `<div style="background: ${color}; width: 30px; height: 30px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${index + 1}</div>`,
                    iconSize: [30, 30]
                }));
            }
        }

        // Open question
        function openQuestion(index) {
            const q = questions[index];
            
            if (q.answered) {
                alert('–í—ã —É–∂–µ –æ—Ç–≤–µ—Ç–∏–ª–∏ –Ω–∞ —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å!');
                return;
            }

            if (!q.unlocked) {
                alert(`–ü–æ–¥–æ–π–¥–∏—Ç–µ –±–ª–∏–∂–µ! –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –≤–æ–ø—Ä–æ—Å–∞: ${q.distance.toFixed(1)}–º (–Ω—É–∂–Ω–æ: ${UNLOCK_DISTANCE}–º)`);
                return;
            }

            showQuestion(index);
        }

        // Show question screen
        function showQuestion(index) {
            const q = questions[index];
            
            document.getElementById('proximityStatus').innerHTML = `
                <div class="proximity-ok">
                    ‚úÖ –í–æ–ø—Ä–æ—Å ${index + 1} —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω! –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${q.distance.toFixed(1)}–º
                </div>
            `;
            
            // Create question card with image
            const questionCard = document.querySelector('.question-card');
            questionCard.innerHTML = `
                <img src="${q.image}" alt="–í–æ–ø—Ä–æ—Å ${index + 1}" class="question-image" onerror="this.style.display='none'">
                <div class="question-text">${q.question}</div>
                <div class="options" id="optionsContainer"></div>
            `;
            
            const optionsContainer = document.getElementById('optionsContainer');
            
            q.options.forEach((option, optIndex) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'option';
                optionDiv.textContent = option;
                optionDiv.onclick = () => selectAnswer(index, optIndex);
                optionsContainer.appendChild(optionDiv);
            });

            showScreen('question-screen');
        }

        // Handle answer selection
        function selectAnswer(questionIndex, selectedIndex) {
            const question = questions[questionIndex];
            const options = document.querySelectorAll('.option');
            
            // Disable all options
            options.forEach(opt => {
                opt.classList.add('disabled');
                opt.onclick = null;
            });

            // Mark correct and incorrect
            options[question.correct].classList.add('correct');
            if (selectedIndex !== question.correct) {
                options[selectedIndex].classList.add('incorrect');
            } else {
                score++;
            }

            // Store answer
            question.answered = true;
            question.userAnswer = selectedIndex;

            // Update marker
            updateMarkerColor(questionIndex);

            // Show result and go back after delay
            setTimeout(() => {
                backToMap();
            }, 2000);
        }

        // Back to map
        function backToMap() {
            showScreen('map-screen');
        }

        // Get random questions from pool
        function getRandomQuestions(count) {
            const shuffled = [...questionPool].sort(() => Math.random() - 0.5);
            return shuffled.slice(0, count).map(q => ({...q}));
        }

        // Generate random location within radius or drawn shape
        function getRandomLocationInRadius(center, radiusInMeters) {
            if (!drawnShape) {
                // Fallback to circle if no shape drawn
                radiusInMeters = 500;
            }
            
            // Get bounds of the drawn shape
            const bounds = drawnShape ? drawnShape.getBounds() : null;
            
            if (bounds) {
                // Generate random point within bounds
                let point;
                let attempts = 0;
                const maxAttempts = 100;
                
                do {
                    const lat = bounds.getSouth() + Math.random() * (bounds.getNorth() - bounds.getSouth());
                    const lng = bounds.getWest() + Math.random() * (bounds.getEast() - bounds.getWest());
                    point = L.latLng(lat, lng);
                    attempts++;
                    
                    // Check if point is inside the shape
                    if (currentDrawingTool === 'circle') {
                        const distance = center.distanceTo ? 
                            L.latLng(center).distanceTo(point) : 
                            L.latLng(center.lat, center.lng).distanceTo(point);
                        if (distance <= drawnShape.getRadius()) {
                            return {lat: point.lat, lng: point.lng};
                        }
                    } else {
                        // For rectangle and polygon, check if point is in bounds
                        // Simple bounds check for rectangle/polygon
                        return {lat: point.lat, lng: point.lng};
                    }
                } while (attempts < maxAttempts);
                
                // Fallback to center if couldn't find point
                return {lat: center.lat, lng: center.lng};
            } else {
                // Original circle logic as fallback
                const radiusInDegrees = radiusInMeters / 111320;
                
                const u = Math.random();
                const v = Math.random();
                const w = radiusInDegrees * Math.sqrt(u);
                const t = 2 * Math.PI * v;
                const x = w * Math.cos(t);
                const y = w * Math.sin(t);
                
                return {
                    lat: center.lat + y,
                    lng: center.lng + x / Math.cos(center.lat * Math.PI / 180)
                };
            }
        }

        // Calculate distance between two points
        function calculateDistance(point1, point2) {
            const R = 6371e3;
            const œÜ1 = point1.lat * Math.PI / 180;
            const œÜ2 = point2.lat * Math.PI / 180;
            const ŒîœÜ = (point2.lat - point1.lat) * Math.PI / 180;
            const ŒîŒª = (point2.lng - point1.lng) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                    Math.cos(œÜ1) * Math.cos(œÜ2) *
                    Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        // Show results screen
        function showResults() {
            stopLocationTracking();
            stopCompassTracking();
            
            const answeredCount = questions.filter(q => q.answered).length;
            document.getElementById('finalScore').textContent = `${score}/${answeredCount}`;
            
            let feedback = '';
            if (answeredCount === 0) {
                feedback = "–í—ã –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª–∏ –Ω–∏ –Ω–∞ –æ–¥–∏–Ω –≤–æ–ø—Ä–æ—Å! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞! üéÆ";
            } else {
                const percentage = (score / answeredCount) * 100;
                
                if (percentage === 100) {
                    feedback = "–ò–¥–µ–∞–ª—å–Ω–æ! –í—ã –Ω–∞—Å—Ç–æ—è—â–∏–π —ç–∫—Å–ø–µ—Ä—Ç Disney! üåü";
                } else if (percentage >= 80) {
                    feedback = "–û—Ç–ª–∏—á–Ω–æ! –í—ã –∑–Ω–∞–µ—Ç–µ Disney! üéä";
                } else if (percentage >= 60) {
                    feedback = "–•–æ—Ä–æ—à–æ! –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Å–º–æ—Ç—Ä–µ—Ç—å –∫–ª–∞—Å—Å–∏–∫—É! üé¨";
                } else {
                    feedback = "–ù–µ–ø–ª–æ—Ö–æ! –í—Ä–µ–º—è –¥–ª—è –º–∞—Ä–∞—Ñ–æ–Ω–∞ Disney! üçø";
                }
            }
            
            document.getElementById('feedback').textContent = feedback;
            
            // Show detailed results
            const resultsList = document.getElementById('resultsList');
            resultsList.innerHTML = '<h3 style="margin-bottom: 15px;">–í–∞—à–∏ –æ—Ç–≤–µ—Ç—ã:</h3>';
            
            questions.forEach((q, index) => {
                if (q.answered) {
                    const isCorrect = q.userAnswer === q.correct;
                    const resultItem = document.createElement('div');
                    resultItem.className = `result-item ${isCorrect ? 'correct' : 'incorrect'}`;
                    resultItem.innerHTML = `
                        <div class="result-question">${index + 1}. ${q.question}</div>
                        <div class="result-answer">
                            –í–∞—à –æ—Ç–≤–µ—Ç: ${q.options[q.userAnswer]} ${isCorrect ? '‚úì' : '‚úó'}<br>
                            ${!isCorrect ? `–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: ${q.options[q.correct]}` : ''}
                        </div>
                    `;
                    resultsList.appendChild(resultItem);
                }
            });

            showScreen('results-screen');
        }

        // Reset game
        function resetGame() {
            stopLocationTracking();
            stopCompassTracking();
            questions = [];
            questionMarkers = [];
            score = 0;
            currentHeading = 0;
            selectedCenter = null;
            if (map) {
                map.remove();
                map = null;
            }
            if (selectorMap) {
                selectorMap.remove();
                selectorMap = null;
            }
            showScreen('setup-screen');
            getUserLocation();
        }

        // Show specific screen
        function showScreen(screenClass) {
            document.querySelectorAll('.setup-screen, .map-selector-screen, .map-screen, .question-screen, .results-screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.querySelector(`.${screenClass}`).classList.add('active');
        }
    </script>
</body>
</html>
